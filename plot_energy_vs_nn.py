import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.path import Path
from scipy.spatial import Voronoi, voronoi_plot_2d
from scipy.spatial.distance import pdist, squareform
import matplotlib.gridspec as gridspec
import numpy as np

#libraries developed by DM
#import classColloid.plotColloid as plotColloid //OLD
import colloid_plot_library as cpl
import data_importerDM as di

import sys

#########################################################
#color code for Voronoi faces
#########################################################
#this will map to Voronoi cell coloring by 
#the number of sides the particular cell has
#4=blue, 5-lightblue, etc with a linear shift in 

colors = ['blue','skyblue','gray','firebrick']
plt.rc('font',size=22)
###############################################################


#########################################################
#implementation of shoelace method
#########################################################
def PolygonArea(corners):
    '''
    The shoelace method is a way to find the area of a polygon
    given its vertices.   
    This specifically takes all of the space contained within the 
    vertices and eliminates problems with the order 
    the vertices are considered.

    http://stackoverflow.com/questions/24467972/calculate-area-of-polygon-given-x-y-coordinates
    https://en.wikipedia.org/wiki/Shoelace_formula

    required argument(s)
    corners = a list of [xi,yi] coordinates (vor.vertices[i])
    '''
    n = len(corners) # of corners 
    area = 0.0       #initialize the area as zero, we will +=

    #loop through all of the vertices/corners
    for i in range(n):
        
        j = (i + 1) % n
        area += corners[i][0] * corners[j][1]
        area -= corners[j][0] * corners[i][1]
        
    area = abs(area) / 2.0
    return area

########################################################
#calculate an approximate average area using a histogram
########################################################
def calc_max_area(vor):
    '''
    this is a hack that works at some densities/clustering systems 
    to find voronoi cells that are simply too big to include 
    in voronoi statistics because they are actually part of 
    the systems edge

    calculate an approximate average area using a histogram
    could do this while looping over the cells to keep
    for efficiency sake

    required arguments
    vor: voronoi tessellation data structure generated by scipy
    '''

    num_cells=len(vor.regions)
    area_to_histogram=np.zeros(num_cells)
    
    #for q,region in zip(range(num_cells),vor.regions):
    for q,index in zip(range(num_cells),vor.point_region):

        region=vor.regions[index]
        if not -1 in region:
            
            polygon = [vor.vertices[i] for i in region]
                
            if len(polygon) > 3 and len(polygon) < 8: 
                    
                area_to_histogram[q]=PolygonArea(polygon)

    #area_to_histogram is an array that contains a list 
    #of all voronoi cells in the entire system
    #we need to find the mode and set the max area just above that

    freq,bins=np.histogram(area_to_histogram,bins=np.arange(200))
    
    #find the area that most of the particles sit within
    if 0:
        print freq
        print bins
        exit()

    #estimate where to cut off using the freq of areas - 80%?

    number_zero_freq=0
    total_cells=0
    for i in range(len(bins)):

        total_cells+=freq[i]

        if freq[i]==0:
            number_zero_freq+=1


        if number_zero_freq==4 or i==10:
            break


    max_area=bins[i]

    print("The number of cells in the tessellation is: ", num_cells)

    return max_area

###############################################################
###############################################################
###############################################################
def voronoi_statistics(vor,max_area=None,periodic=False,SX=None,SY=None,
                       distance_cut=None):
    '''
    given the scipy voronoi tessellation and data structures,
    loop through the values, and count the pN statistics
    '''

    #numpy array meant to hold the integer number of particles
    #containing 4 sides, 5 sides, 6 sides, and 7 sides
    pN=np.zeros(4)
    pcenter=0   #total cells with area < max_area, these are "center"
    pedge=0     #

    #count based on side number
    #for region in vor.regions:
    for index in vor.point_region:
        region=vor.regions[index]

        if not -1 in region:

            #################################################
            #polygon = a series of points outlining a polygon
            #which surrounds a particle (colloid etc)
            #structure is an array of pairs of points
            #polygon=[[x1,y1],[x2,y2],etc]
            #################################################
            polygon = [vor.vertices[i] for i in region]

            #################################################
            #number of sides of this poly which 
            #are simply too short to be considered "real"
            #for statistics and drawing
            #################################################
            short_side=0 

            #our polygon needs a set number of faces to be counted
            if len(polygon) > 3 and len(polygon) < 8: 

                if distance_cut:
                    #perform a cut on len(polygon)
                    #based small vertex/ridge lengths

                    d = squareform(pdist(polygon, 'euclidean'))
                    all_distances = d.flatten()

                    for distance in all_distances:
                        if distance > 0.0 and distance < (SX/240.0):
                            '''
                            opportunity to normalize by total length
                            and throw out the distances that 
                            are a small small percentage of that total
                            '''
                            #print distance
                            short_side+=1

                            #print short_side
                            #all_distance is length N^2, so divide short_side
                        short_side /= 2

                        '''end new chunk of code
                        '''
                else:
                    short_side=0

                #if we're restricing area, check the polygon is the right size
                if (max_area and PolygonArea(polygon) < max_area):

                    pN[len(polygon)-4-short_side]+=1
                    pcenter+=1
                
                elif max_area==None:

                    #otherwise count the particle no matter what
                    pN[len(polygon)-4]+=1
                    pcenter+=1


            else:
                pedge+=1


    return (pN, pcenter, pedge)

###############################################################
def calc_voronoi_tessellation(x_p,y_p, #max_area=1.5,
                              periodic=False,SX=None,SY=None,
                              distance_cut=None):
    '''
    Use the scipy library on the given numpy arrays for 
    the positions of the particles

    x_p:      numpy array containing all x-positions of particles
    y_p:      numpy array containing all y-positions of particles

    #not used, not appropriate in original tessellation
    #max_area: a hack method to eliminate coloring in 
    #          edges when the particles are in clumps

    periodic: boolean to determine whether to consider PBC
    SX:       system size, in x, necessary for PBC
    SY:       system size, in y, necessary for PBC
    '''

    if periodic:
        if SX==None or SY==None:
            print("Can't make periodic Voronoi diagram without these.")
            return

        #total number of particles in the system
        n=len(x_p)

        #new numpy array to hold the 
        #periodic repeats + original system
        tiled_x_p = np.zeros(n*9)
        tiled_y_p = np.zeros(n*9)

        #loop through the neighboring tiles
        for i,shiftx in enumerate([-1.0, 0.0, 1.0]):
            for j,shifty in enumerate([-1.0, 0.0, 1.0]):
                #nifty numpy array math for 
                #creating the periodic repeats
                tiled_x_p[(i+j*3)*n:(i+j*3+1)*n] = x_p + shiftx*SX
                tiled_y_p[(i+j*3)*n:(i+j*3+1)*n] = y_p + shifty*SY

        ##########################################################
        #combine the x and y arrays into a single data structure
        #for the voronoi tessellation.
        ##########################################################
        np_points = np.column_stack((tiled_x_p,tiled_y_p))

    ##########################################################
    #else = NOT doing PBC, still need to
    #put the x and y data into 
    #a single np.array for voronoi analysis
    #########################################################
    else:
        np_points = np.column_stack((x_p,y_p))

    #########################################################
    #do Voronoi analysis using scipy algorithm, 
    #which calls qhull... I think
    #
    vor = Voronoi(np_points)
    #########################################################

    #########################################################
    #now we ruthlessly delete the tiled particles
    #so we don't include them in analysis
    #########################################################
    if periodic:        

        #want to delete the particles in the 8 additional tiles
        points_to_delete=np.zeros(8*n)
        j=0

        #identify i values of particles NOT in the original box
        for i,point in zip(range(len(vor.points)),vor.points):

            #surely there is a more efficient way to 
            #measure if particle NOT in box,
            #but I don't know what that is.
            if point[0]>SX or point[0]<0.0 or point[1]<0.0 or point[1]>SY:
                points_to_delete[j]=i
                j+=1

        ###########################################################
        #check that all of the particles to be remove were counted
        #if this fails, it is game over
        ###########################################################
        if j!=8*n:
            print("Somehow didn't find all of the extra particles")
            sys.exit()
        else:

            count=0
            ###########################################################
            #this is how I learned about these data structures
            #don't delete
            ###########################################################
            '''
            for array in [vor.points,
                          vor.vertices,
                          vor.ridge_points,
                          vor.regions,
                          vor.point_region]:
                print("count=",count)
                print len(array)
                print array
                count+=1
            '''
            ###########################################################
            #helpful data structure learning tool
            #don't delete
            ###########################################################
            '''
            for data_point in vor.point_region:
                print vor.points[data_point-1]
            '''
            ###########################################################
            #delete the graft from the two arrays that count by points
            ###########################################################
            vor.points     =np.delete(vor.points,      points_to_delete,0)
            vor.point_region=np.delete(vor.point_region,points_to_delete,0)

            #everybody else is too full,
            #and needs to get trimmed 
            #regions gets trimmed by point_region
            #not yet sure about the rest

    return vor

###################################################################
###################################################################
###################################################################
###################################################################
def plot_voronoi_tessellation(vor,x_p,y_p,
                              max_area=100000.0,  #set high
                              periodic=False,
                              SX=None,SY=None,plotEdges=False,
                              distance_cut=None):

    ##################################################################
    #color by area
    ##################################################################
    '''
    http://stackoverflow.com/questions/20515554/colorize-voronoi-diagram
    '''
    
    colors = []
    #for region in vor.regions:
    for index in vor.point_region:
        region=vor.regions[index]
        short_side=0
        polygon = [vor.vertices[i] for i in region]
        if PolygonArea(polygon) < max_area:
            colors.append(len(polygon))
        else:
            colors.append(0)

    return colors

def calc_energy(x_p, y_p, x_d, y_d, spring, disorder_mag,
               particle_rad, disorder_rad):

    '''
    Use the scipy library on the given numpy arrays for 
    the positions of the particles
    
    x_p:      numpy array containing all x-positions of particles
    y_p:      numpy array containing all y-positions of particles
    x_d:      numpy array containing all x-positions of disorder
    y_d:      numpy array containing all y-positions of disorder
    spring:   spring constant of particle-particle reactions
    disorder_mag: magnitude of potential for disorder
    '''
    energy = []
    #Calculate energy from neighboring particles
    for i in range(len(x_p)):
        disorder_energy = 0
        particle_energy = 0
        for p in range(len(x_p)):
            if (i != p):
                distance = np.sqrt((x_p[i] - x_p[p])**2 + ((y_p[i] - y_p[p])**2))
            else:
                distance = 100
            if (distance < 2*particle_rad):
                particle_energy += 0.5 * spring * (particle_rad-distance)**2
                
    #Calculate energy from overlapping disorder
        for p in range(len(x_d)):
                distance = np.sqrt((x_p[i] - x_d[p])**2 + ((y_p[i] - y_d[p])**2))
                if (distance < disorder_rad):
                    disorder_energy += abs(disorder_mag * (disorder_rad-distance)**2)

        energy.append(disorder_energy + particle_energy)
    return energy

################################################################
################################################################
if __name__ == "__main__":

    #all possibilities
    data_types = [0,1,2] #["smtest", "ascii", "binary"]

    #the one we will use
    data_type = data_types[0]

    if data_type == 0:
        print("Reading directly from smtest (binary)")
        print("Writing velocity_data/XV*npy files")

    elif data_type == 1:
        print("Reading from velocity_data/XV* files (ascii)")
        print("Writing velocity_data/XV*npy files")

    elif data_type == 2:
        print("Reading velocity_data/XV*npy files (binary)")

    #--------------------------------------------------------------
    #get data for initial frame, 
    #---------------------------------------------------------------
    inputfile = "Pa0"
    
    (Sx, Sy, radius, maxtime, writemovietime ) = cpl.get_input_data(inputfile)

    out_file1="EnergiesAndNN.txt"
    out_file2="../../AverageNNEnergies.txt"

    #---------------------------
    #get and parse data
    #---------------------------

    datafile_prefix = "velocity_data/XV_data_t="
    pin_file = "pin_array.dat"
    time = 49950
    try: 
        pin_data = di.get_data(pin_file,5,sep=" ")
    except:
        print("No pinning data in expected format")
        sys.exit()       
    xd = pin_data[1]
    yd = pin_data[2]
    pin_rad = pin_data[3][0]
    pin_mag = pin_data[4][0]
    total_energy = 0
    EnergyArray = []

    id,type,xp,yp = cpl.get_and_parse_data(data_type, time,
                                           movie_type="cmovie")

    #Calculate nearest neigbors
    vor_data=calc_voronoi_tessellation(xp,yp) 
    voronoi_statistics(vor_data)  
    vor_sides=plot_voronoi_tessellation(vor_data,xp,yp,max_area=1.2)
    
    #Calculate particle energies
    kspring = 50
    energy_data=calc_energy(xp,yp,xd,yd,kspring,pin_mag,radius,pin_rad)
    
    for i in range(len(xp)):
        with open(out_file1, "a") as myfile:
            myfile.write("%f" %vor_sides[i])
            myfile.write(" ")
            myfile.write("%f" %energy_data[i])
            myfile.write("\n")

    sum4 = 0
    sum5 = 0
    sum6 = 0
    sum7 = 0
    num4 = 0
    num5 = 0
    num6 = 0
    num7 = 0
    
    for j in range(len(xp)):
        if vor_sides[j] == 4:
            sum4 += energy_data[j]
            num4 += 1
        if vor_sides[j] == 5:
            sum5 += energy_data[j]
            num5 += 1
        if vor_sides[j] == 6:
            sum6 += energy_data[j]
            num6 += 1            
        if vor_sides[j] == 7:
            sum7 += energy_data[j]
            num7 += 1

    avg4 = sum4/num4
    avg5 = sum5/num5
    avg6 = sum6/num6
    avg7 = sum7/num7

    print("\n")
    print("Average Energy for P4 = ")
    print(avg4)
    print("\n")
    print("Average Energy for P5 = ")
    print(avg5)
    print("\n")
    print("Average Energy for P6 = ")
    print(avg6)
    print("\n")
    print("Average Energy for P7 = ")
    print(avg7)

    with open(out_file2, "a") as myfile:
        myfile.write("%f" %avg4)
        myfile.write(" ")
        myfile.write("%f" %avg5)
        myfile.write(" ")
        myfile.write("%f" %avg6)
        myfile.write(" ")
        myfile.write("%f" %avg7)
        myfile.write("\n")
    rows=2
    columns=2

    gs = gridspec.GridSpec(rows,columns)
    fig = plt.figure(figsize=(6*columns,6*rows))
    ax1 = fig.add_subplot(gs[:])
    
    ax1.set_xlabel("Number of Nearest Neigbors")
    ax1.set_ylabel("Energy")   
    ax1.set_title("Energy vs Nearest Neigbors")
    ax1.set_xlim(3,8)

    ax1.plot(vor_sides, energy_data, ".")
    out_name="EnergyNNPlot.png"
    fig.savefig(out_name)
    
    sys.exit()
